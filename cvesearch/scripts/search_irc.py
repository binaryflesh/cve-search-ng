#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Simple IRC bot to query for the last entries in the CVE database
#
# current command supported is:
#
# last <max>
# cvetweet <max>
# browse
# search <vendor>\<product>
# get <cve>
#
# You need to connect the IRC bot to the IRC Server you want to access it from.
#
# Software is free software released under the "GNU Affero General Public License v3.0"
#
# Copyright (c) 2015-2019  Pieter-Jan Moreels - pieter-jan@pidgey.net

# Imports
from . import _search, pass_context, STRING, INT, BOOL

import irc.bot
from irc.bot import SingleServerIRCBot
from irc.connection import Factory
import irc.strings
import json
import signal
import ssl as _ssl

# BSON MongoDB include ugly stuff that needs to be processed for standard JSON
from bson import json_util

from ..api import API


class IRCBot(SingleServerIRCBot):
    def __init__(self, channel, nickname, server, port, password=None, username=None, **kwargs):
        if not username:
            username = nickname
        self.verbose = kwargs.get('verbose')
        self.trigger = kwargs.get('trigger')
        self.max_queries = kwargs.get('max_queries')
        super().__init__(self, [(server, port)], nickname, username, **kwargs)
        self.channel = channel
        self.api = API()

    def on_nicknameinuse(self, c, e):
        c.nick(c.get_nickname() + "_")

    def on_welcome(self, c, e):
        if self.verbose:
            search_irc.echo("Server welcomed us")
        for chan in self.channel:
            if not chan.startswith('#'):
                chan = ("#%s" % chan)
            if self.verbose:
                search_irc.echo("joining %s" % chan)
            c.join(chan)

    def on_privmsg(self, c, e):
        self.do_command(e, e.arguments[0])

    def on_pubmsg(self, c, e):
        line = e.arguments[0]
        if line.startswith(self.trigger):
            self.do_command(e, line[len(self.trigger):])
        return

    def reply(self, e, reply):
        if isinstance(reply, (dict, list)):
            # reply = json.dumps(reply, sort_keys=True, indent=4, default=json_util.default, ensure_ascii=True)
            reply = json.dumps(reply, sort_keys=True, ensure_ascii=True, default=json_util.default)
        else:
            reply = str(reply)

        if e.target == self.connection.nickname:
            target = e.source.nick
        else:
            target = e.target
        _list = reply.split('\n')
        chunk_size = 512 - 12 - len(e.target)  # 512 - len("PRIVMSG") - len(" :") - CR/LF - target

        _list = [[x[i:i+chunk_size] for i in range(0, len(x), chunk_size)] for x in _list]
        _list = [item for sublist in _list for item in sublist] # flatten list
        for r in _list[:4]:
            self.connection.privmsg(target, r)

    def do_command(self, e, cmd):
        def last(option):
            limit = int(option) if option else 10
            if limit > self.max_queries or limit < 1:
                self.reply(e, "Request not in range 0-%d" % self.max_queries)
            return self.api.api_last(limit)
            # self.reply(e, self.api.api_last(limit))

        def cve(option):
            if option is None:
                return "A cve-id must be specified"
            return self.api.api_cve(option)

        if not cmd:
            pass
        parts = cmd.split(' ', 1)
        cmd = parts[0]
        option = parts[1] if len(parts) == 2 else None

        if cmd == "die":
            self.die()
        elif cmd in ["last", "recent"]:
            self.reply(e, last(option))
        elif cmd in ["get", "cve"]:
            self.reply(e, cve(option))
        elif cmd in ["browse", "vendor"]:
            self.reply(e, self.api.api_browse(option))
        elif cmd in ["search", "product"]:
            parts = option.split()
            if len(parts) < 2:
                return self.reply(e, "Usage: search <vendor> <product>")
            return self.reply(e, self.api.api_search(parts[0], parts[1]))
        elif cmd in ["cvetweet", "tweet"]:
            text = ""
            cves = []
            if option.lower().startswith("cve-"):
                cves.append(cve(option))
            else:
                cves = last(option)
            for t in cves:
                text += str(t['id']) + " , " + str(t['summary']) + " " + " , ".join(t['references']) + "\n"
            return self.reply(e, text)
        else:
            return self.reply(e, "Not understood: " + cmd)


# signal handlers
@pass_context
def sig_handler(sig, frame):
    search_irc.echo('Caught signal: %s\nShutting down' % sig)
    bot.die()
    return bot


@_search.command('irc', invoke_without_command=True)
@pass_context
@_search.option('-s', '--server', type=STRING, default='127.0.0.1')
@_search.option('-p', '--port', type=INT, default=6667)
@_search.option('-n', '--nickname', type=STRING, default='cve-search')
@_search.argument('-w', '--password', type=STRING)
@_search.option('-u', '--username', type=STRING)
@_search.option('-c', '--channels', type=list(STRING), default=['cve-search'])
@_search.option('--ssl', type=BOOL, default=False)
@_search.option('-v', '--verbose', type=BOOL, default=False)
@_search.option('-t', '--trigger', type=STRING, default='.')
@_search.option('-m', '--max', type=INT, default=20)
def search_irc(server, port, nick, password, user, chans, ssl, verbose, trigger, max_queries):
    """

    :param server:
    :param port:
    :param nick:
    :param password:
    :param user:
    :param chans:
    :param ssl:
    :param verbose:
    :return:
    """
    global bot

    if ssl:
        search_irc.echo('using ssl')
        ssl_factory = irc.connection.Factory(wrapper=_ssl.wrap_socket)
        bot = IRCBot(chans, nick, server, port,
                     password=password, username=user, connect_factory=ssl_factory,
                     trigger=trigger, max_queries=max_queries)
    else:
        bot = IRCBot(chans, nick, server, port, password=password,
                     username=user, trigger=trigger, max_queries=max_queries)
    # map(signal.signal, zip((signal.SIGTERM, signal.SIGINT), sig_handler))
    signal.signal(signal.SIGTERM, sig_handler)
    signal.signal(signal.SIGINT, sig_handler)
    if verbose:
        search_irc.echo('Connecting to server')
    bot.start()


if __name__ == '__main__':
    search_irc(input)
